# ü§ñ Bot de Trading ML - Implementa√ß√£o Completa

Um bot de trading inteligente powered por Machine Learning com interface profissional em tema escuro, funcionalidade completa de Auto Trade e sistema avan√ßado de gerenciamento de trades com Take Profit/Stop Loss. Este projeto utiliza Next.js 15, TypeScript e APIs de IA para fornecer previs√µes de mercado e execu√ß√£o de trades automatizados.

## üåü Funcionalidades Principais

### üéØ Interface Profissional
- **Tema Escuro Moderno**: Design elegante com gradientes e efeitos glassmorphism
- **Dashboard Completo**: Tudo em uma √∫nica tela, com abas organizadas para diferentes funcionalidades
- **Design Responsivo**: Otimizado para desktop e dispositivos m√≥veis
- **Componentes UI/UX**: Biblioteca shadcn/ui para experi√™ncia premium

### üß† Machine Learning Avan√ßado
- **Previs√µes em Tempo Real**: An√°lise de mercado usando IA com ZAI SDK
- **Indicadores T√©cnicos**: RSI, MACD, SMA, Bandas de Bollinger
- **Pontua√ß√£o de Confian√ßa**: Cada previs√£o inclui n√≠vel de confian√ßa (70-98%)
- **Modelos Neurais**: Simula√ß√£o de rede neural LSTM para an√°lise de padr√µes

### üíº Sistema de Trading Completo
- **Execu√ß√£o R√°pida**: Compra e venda instant√¢nea com valida√ß√£o
- **Gest√£o de Portfolio**: Acompanhamento em tempo real do valor e P&L
- **Hist√≥rico de Trades**: Registro completo com m√©tricas de performance
- **Gerenciamento de Risco**: Stop loss, take profit e dimensionamento de posi√ß√£o

### ü§ñ Auto Trade Inteligente
- **Trading Automatizado**: Execu√ß√£o autom√°tica de trades baseada em ML
- **Configura√ß√µes Personaliz√°veis**: Controle total sobre par√¢metros de auto trade
- **Gest√£o de Risco Avan√ßada**: Limites di√°rios, confian√ßa m√≠nima e multiplicadores
- **Monitoramento em Tempo Real**: Status e estat√≠sticas de auto trade

### üõ°Ô∏è **NOVO: Sistema Avan√ßado de Fechamento de Trades**
- **Take Profit/Stop Loss Autom√°ticos**: Configura√ß√£o individual por trade
- **An√°lise LSTM para Fechamento**: IA identifica momentos √≥timos para encerrar posi√ß√µes
- **Fechamento Inteligente**: Combina√ß√£o de TP/SL fixos com sinais din√¢micos de mercado
- **Monitoramento Cont√≠nuo**: Verifica√ß√£o a cada 10 segundos para condi√ß√µes de fechamento
- **Interface de Gerenciamento**: Controle completo sobre trades abertos com progress bars visuais

### üìä An√°lise de Mercado
- **Dados em Tempo Real**: Pre√ßos atualizados a cada 3 segundos
- **Ativos M√∫ltiplos**: BTC, ETH, SOL, ADA, DOT e mais
- **Volume e Market Cap**: Dados completos de mercado
- **An√°lise T√©cnica**: Indicadores e padr√µes de mercado

### üéÆ **NOVO: Interface de Gerenciamento de Trades**
- **Aba "Trades Abertos"**: Gerenciamento centralizado de todas as posi√ß√µes
- **Visualiza√ß√£o Detalhada**: Pre√ßo de entrada, atual, TP, SL, P&L unrealizado
- **Barras de Progresso**: Indicadores visuais de progresso para TP/SL
- **Controle Manual**: Bot√£o para fechamento manual quando necess√°rio
- **Notifica√ß√µes em Tempo Real**: Alertas para trades fechados automaticamente

## üöÄ Arquitetura do Sistema

### üì° API Endpoints
```
/api/trading/
‚îú‚îÄ‚îÄ market/          # Dados de mercado e pre√ßos
‚îú‚îÄ‚îÄ predict/         # Previs√µes ML para ativos
‚îú‚îÄ‚îÄ execute/         # Execu√ß√£o de trades com TP/SL
‚îî‚îÄ‚îÄ close/           # Gerenciamento de trades abertos
    ‚îú‚îÄ‚îÄ GET          # Monitoramento e auto-fechamento
    ‚îî‚îÄ‚îÄ POST         # Fechamento manual de trades
```

### üß† Componentes de IA
- **Previs√£o de Entrada**: LSTM analisa padr√µes para identificar oportunidades
- **Sinais de Fechamento**: IA avalia momento √≥timo para encerrar posi√ß√µes
- **An√°lise de Risco**: Avalia√ß√£o cont√≠nua de condi√ß√µes de mercado
- **Aprendizado Cont√≠nuo**: Melhora das decis√µes com base em resultados hist√≥ricos

### üîÑ Fluxo de Trading
1. **An√°lise de Mercado** ‚Üí Coleta de dados e indicadores t√©cnicos
2. **Previs√£o ML** ‚Üí Gera√ß√£o de sinais de compra/venda com confian√ßa
3. **Execu√ß√£o** ‚Üí Abertura de posi√ß√£o com TP/SL autom√°ticos
4. **Monitoramento** ‚Üí Acompanhamento cont√≠nuo da posi√ß√£o
5. **Fechamento Inteligente** ‚Üí Encerramento baseado em TP/SL ou sinais LSTM

## üéØ Configura√ß√µes de Bot

### Par√¢metros de Auto Trade
- **Ativos Habilitados**: Selecione quais criptomoedas monitorar
- **Confian√ßa M√≠nima**: Ajuste o threshold para execu√ß√£o (50-95%)
- **M√°ximo de Trades por Dia**: Limite di√°rio para controle de risco (1-50)
- **Intervalo entre Trades**: Tempo m√≠nimo entre execu√ß√µes (10-300s)
- **Multiplicador de Risco**: Ajuste agressividade das opera√ß√µes (0.1x-3.0x)

### Configura√ß√µes de TP/SL
- **Take Profit**: Porcentagem de lucro alvo (padr√£o: 10%)
- **Stop Loss**: Porcentagem m√°xima de perda (padr√£o: 5%)
- **Fechamento por LSTM**: Habilita an√°lise inteligente para fechamento
- **Timeout de Trade**: Dura√ß√£o m√°xima de posi√ß√£o (padr√£o: 24h)

## üõ†Ô∏è Tecnologias Utilizadas

### Frontend
- **Next.js 15**: Framework React com Server Components
- **TypeScript**: Tipagem est√°tica para maior seguran√ßa
- **Tailwind CSS**: Estiliza√ß√£o utilit√°ria e responsiva
- **shadcn/ui**: Componentes UI premium e acess√≠veis
- **Lucide React**: √çcones modernos e consistentes

### Backend
- **API Routes**: Endpoints RESTful no Next.js
- **ZAI SDK**: Integra√ß√£o com modelos de linguagem avan√ßados
- **Socket.io**: Comunica√ß√£o em tempo real
- **Prisma**: ORM para gerenciamento de banco de dados

### Machine Learning
- **LSTM Simulation**: Redes neurais recorrentes para an√°lise temporal
- **An√°lise T√©cnica**: C√°lculo de indicadores t√©cnicos
- **Previs√£o de Sinais**: Classifica√ß√£o de oportunidades de trading
- **Otimiza√ß√£o de Sa√≠da**: Identifica√ß√£o de momentos de fechamento

## üöÄ Como Implementar com Dados Reais

### 1. Configurar APIs de Mercado

#### üìà Integra√ß√£o com Binance API
```bash
# Instalar biblioteca Binance
npm install binance-api-node
```

```typescript
// src/lib/binance.ts
import Binance from 'binance-api-node'

const binance = Binance({
  apiKey: process.env.BINANCE_API_KEY,
  apiSecret: process.env.BINANCE_API_SECRET,
})

export const getMarketData = async (symbol: string) => {
  try {
    const ticker = await binance.prices({ symbol: `${symbol}USDT` })
    const twentyFourhr = await binance.dailyStats({ symbol: `${symbol}USDT` })
    
    return {
      symbol,
      price: parseFloat(ticker[`${symbol}USDT`]),
      change_24h: parseFloat(twentyFourhr.priceChange),
      change_percent_24h: parseFloat(twentyFourhr.priceChangePercent),
      volume_24h: parseFloat(twentyFourhr.volume),
      high_24h: parseFloat(twentyFourhr.highPrice),
      low_24h: parseFloat(twentyFourhr.lowPrice),
    }
  } catch (error) {
    console.error('Erro ao buscar dados da Binance:', error)
    throw error
  }
}

export const getHistoricalData = async (symbol: string, interval: string = '1h', limit: number = 100) => {
  try {
    const candles = await binance.candles({
      symbol: `${symbol}USDT`,
      interval,
      limit,
    })
    
    return candles.map(candle => ({
      timestamp: new Date(candle.openTime).toISOString(),
      open: parseFloat(candle.open),
      high: parseFloat(candle.high),
      low: parseFloat(candle.low),
      close: parseFloat(candle.close),
      volume: parseFloat(candle.volume),
    }))
  } catch (error) {
    console.error('Erro ao buscar dados hist√≥ricos:', error)
    throw error
  }
}
```

#### üí± Integra√ß√£o com CoinGecko API
```bash
# Instalar biblioteca CoinGecko
npm install coingecko-api
```

```typescript
// src/lib/coingecko.ts
import CoinGecko from 'coingecko-api'

const CoinGeckoClient = new CoinGecko()

export const getMarketOverview = async () => {
  try {
    const data = await CoinGeckoClient.coins.markets({
      vs_currency: 'usd',
      order: 'market_cap_desc',
      per_page: 100,
      page: 1,
      sparkline: false,
    })
    
    return data.data.map(coin => ({
      symbol: coin.symbol.toUpperCase(),
      name: coin.name,
      price: coin.current_price,
      change_24h: coin.price_change_24h,
      change_percent_24h: coin.price_change_percentage_24h,
      volume_24h: coin.total_volume,
      market_cap: coin.market_cap,
      high_24h: coin.high_24h,
      low_24h: coin.low_24h,
    }))
  } catch (error) {
    console.error('Erro ao buscar dados do CoinGecko:', error)
    throw error
  }
}
```

### 2. Configurar Database Real

#### üóÑÔ∏è Configurar PostgreSQL com Prisma
```bash
# Instalar Prisma e PostgreSQL
npm install prisma @prisma/client
npm install pg
npx prisma init
```

```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  balance   Float    @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  trades    Trade[]
  portfolio Portfolio[]
  autoTradeSettings AutoTradeSettings?
}

model Asset {
  symbol     String   @id
  name       String
  price      Float
  change24h  Float
  volume24h  Float
  marketCap  Float
  updatedAt  DateTime @updatedAt
  
  trades     Trade[]
  portfolio  Portfolio[]
}

model Trade {
  id            String   @id @default(cuid())
  userId        String
  assetSymbol   String
  type          TradeType
  amount        Float
  price         Float
  fees          Float    @default(0)
  status        TradeStatus @default(PENDING)
  mlConfidence  Float?
  profit        Float    @default(0)
  isAutoTrade   Boolean  @default(false)
  createdAt     DateTime @default(now())
  executedAt    DateTime?
  
  user          User     @relation(fields: [userId], references: [id])
  asset         Asset    @relation(fields: [assetSymbol], references: [symbol])
}

model Portfolio {
  id         String   @id @default(cuid())
  userId     String
  assetSymbol String
  amount     Float    @default(0)
  avgPrice   Float    @default(0)
  value      Float    @default(0)
  updatedAt  DateTime @updatedAt
  
  user       User     @relation(fields: [userId], references: [id])
  asset      Asset    @relation(fields: [assetSymbol], references: [symbol])
  
  @@unique([userId, assetSymbol])
}

model AutoTradeSettings {
  id               String   @id @default(cuid())
  userId           String   @unique
  enabled          Boolean  @default(false)
  enabledAssets    String[] @default([])
  minConfidence    Int      @default(75)
  maxDailyTrades   Int      @default(10)
  tradeInterval    Int      @default(30)
  riskMultiplier   Float    @default(1.0)
  totalTrades      Int      @default(0)
  successfulTrades Int      @default(0)
  totalProfit      Float    @default(0)
  lastTradeAt      DateTime?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  user             User     @relation(fields: [userId], references: [id])
}

enum TradeType {
  BUY
  SELL
}

enum TradeStatus {
  PENDING
  EXECUTED
  FAILED
  CANCELLED
}
```

```bash
# Criar e migrar database
npx prisma migrate dev --name init
npx prisma generate
```

### 3. Implementar Autentica√ß√£o

#### üîê Configurar NextAuth.js
```bash
npm install next-auth @next-auth/prisma-adapter
```

```typescript
// src/lib/auth.ts
import NextAuth from 'next-auth'
import CredentialsProvider from 'next-auth/providers/credentials'
import { PrismaAdapter } from '@next-auth/prisma-adapter'
import { prisma } from '@/lib/db'

export const authOptions = {
  adapter: PrismaAdapter(prisma),
  providers: [
    CredentialsProvider({
      name: 'credentials',
      credentials: {
        email: { label: 'Email', type: 'email' },
        password: { label: 'Password', type: 'password' }
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null
        }
        
        const user = await prisma.user.findUnique({
          where: { email: credentials.email }
        })
        
        if (!user) {
          return null
        }
        
        // Adicionar verifica√ß√£o de senha aqui
        return {
          id: user.id,
          email: user.email,
          balance: user.balance
        }
      }
    })
  ],
  session: {
    strategy: 'jwt'
  },
  callbacks: {
    async jwt({ token, user }) {
      if (user) {
        token.balance = user.balance
      }
      return token
    },
    async session({ session, token }) {
      if (token) {
        session.user.id = token.sub
        session.user.balance = token.balance
      }
      return session
    }
  }
}
```

### 4. **NOVO: Implementar Sistema de Fechamento Inteligente**

#### üõ°Ô∏è Sistema Avan√ßado de Take Profit/Stop Loss
```typescript
// src/lib/trade-manager.ts
import { prisma } from '@/lib/db'
import { generateLSTMCloseSignal } from './ml-trainer'
import { getMarketData } from './binance'

export class TradeManager {
  async monitorOpenTrades() {
    const openTrades = await prisma.trade.findMany({
      where: { status: 'OPEN' },
      include: { asset: true }
    })

    for (const trade of openTrades) {
      await this.evaluateTradeForClose(trade)
    }
  }

  private async evaluateTradeForClose(trade: any) {
    // Get current market data
    const marketData = await getMarketData(trade.assetSymbol)
    const currentPrice = marketData.price

    // Check TP/SL conditions
    const shouldClose = await this.checkCloseConditions(trade, currentPrice)
    
    if (shouldClose.close) {
      await this.executeClose(trade, shouldClose.reason, currentPrice)
    }
  }

  private async checkCloseConditions(trade: any, currentPrice: number) {
    // Check Take Profit
    if (trade.takeProfit && ((trade.type === 'BUY' && currentPrice >= trade.takeProfit) ||
        (trade.type === 'SELL' && currentPrice <= trade.takeProfit))) {
      return { close: true, reason: 'take_profit' }
    }

    // Check Stop Loss
    if (trade.stopLoss && ((trade.type === 'BUY' && currentPrice <= trade.stopLoss) ||
        (trade.type === 'SELL' && currentPrice >= trade.stopLoss))) {
      return { close: true, reason: 'stop_loss' }
    }

    // Check LSTM signals for trades older than 1 hour
    const tradeAge = Date.now() - new Date(trade.createdAt).getTime()
    if (tradeAge > 60 * 60 * 1000) {
      const lstmSignal = await generateLSTMCloseSignal({
        symbol: trade.assetSymbol,
        entryPrice: trade.price,
        currentPrice: currentPrice,
        type: trade.type.toLowerCase(),
        mlConfidence: trade.mlConfidence,
        timestamp: trade.createdAt
      })

      if (lstmSignal.should_close && lstmSignal.confidence > 70) {
        return { close: true, reason: 'ml_signal' }
      }
    }

    // Check maximum duration (24 hours)
    if (tradeAge > 24 * 60 * 60 * 1000) {
      return { close: true, reason: 'timeout' }
    }

    return { close: false, reason: 'hold' }
  }

  private async executeClose(trade: any, reason: string, closePrice: number) {
    const realizedPnL = trade.type === 'BUY' 
      ? (closePrice - trade.price) * (trade.amount / trade.price)
      : (trade.price - closePrice) * (trade.amount / trade.price)

    await prisma.trade.update({
      where: { id: trade.id },
      data: {
        status: 'CLOSED',
        closePrice: closePrice,
        realizedPnL: realizedPnL,
        closeReason: reason,
        closedAt: new Date()
      }
    })

    // Update user portfolio and balance
    await this.updatePortfolioOnClose(trade, closePrice, realizedPnL)

    console.log(`Trade ${trade.id} closed: ${reason} - P&L: $${realizedPnL.toFixed(2)}`)
  }

  private async updatePortfolioOnClose(trade: any, closePrice: number, realizedPnL: number) {
    // Update portfolio
    const portfolio = await prisma.portfolio.findUnique({
      where: {
        userId_assetSymbol: {
          userId: trade.userId,
          assetSymbol: trade.assetSymbol
        }
      }
    })

    if (portfolio) {
      const quantity = trade.amount / trade.price
      const newAmount = trade.type === 'BUY' ? 
        portfolio.amount - quantity : portfolio.amount + quantity

      await prisma.portfolio.update({
        where: { id: portfolio.id },
        data: {
          amount: newAmount,
          value: newAmount * closePrice,
          updatedAt: new Date()
        }
      })
    }

    // Update user balance
    await prisma.user.update({
      where: { id: trade.userId },
      data: {
        balance: {
          increment: realizedPnL
        }
      }
    })
  }
}
```

#### üß† An√°lise LSTM para Fechamento de Positions
```typescript
// src/lib/ml-trainer.ts
import ZAI from 'z-ai-web-dev-sdk'

export async function generateLSTMCloseSignal(tradeData: {
  symbol: string
  entryPrice: number
  currentPrice: number
  type: 'buy' | 'sell'
  mlConfidence: number
  timestamp: string
}) {
  try {
    const zai = await ZAI.create()
    
    const priceChange = ((tradeData.currentPrice - tradeData.entryPrice) / tradeData.entryPrice) * 100
    const tradeDuration = Math.floor((Date.now() - new Date(tradeData.timestamp).getTime()) / (1000 * 60 * 60))
    
    const prompt = `
    Analyze the following open trade position and provide a close recommendation:
    
    Trade Details:
    - Symbol: ${tradeData.symbol}
    - Type: ${tradeData.type}
    - Entry Price: $${tradeData.entryPrice.toFixed(2)}
    - Current Price: $${tradeData.currentPrice.toFixed(2)}
    - Price Change: ${priceChange.toFixed(2)}%
    - ML Confidence at Entry: ${tradeData.mlConfidence}%
    - Trade Duration: ${tradeDuration} hours
    
    Based on LSTM analysis and market patterns, provide:
    1. Close recommendation (true/false)
    2. Confidence level (0-100%)
    3. Brief reasoning
    4. Expected additional price movement in percentage if held
    
    Consider factors such as:
    - Profit-taking opportunities
    - Risk reversal signals
    - Market momentum exhaustion
    - Time-based decay of edge
    - Technical indicator divergences
    
    Format your response as JSON:
    {
      "should_close": true,
      "confidence": 85,
      "reasoning": "Technical indicators suggest...",
      "expected_move": 1.5
    }
    `
    
    const completion = await zai.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: 'You are an expert AI trading analyst specializing in position management and exit timing. Analyze open positions and provide optimal close recommendations based on LSTM analysis and market conditions.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3
    })
    
    const response = completion.choices[0]?.message?.content
    
    if (response) {
      try {
        return JSON.parse(response)
      } catch (parseError) {
        return generateRuleBasedCloseSignal(tradeData)
      }
    }
    
    return generateRuleBasedCloseSignal(tradeData)
    
  } catch (error) {
    console.error('LSTM close signal error:', error)
    return generateRuleBasedCloseSignal(tradeData)
  }
}

function generateRuleBasedCloseSignal(tradeData: any) {
  const priceChange = ((tradeData.currentPrice - tradeData.entryPrice) / tradeData.entryPrice) * 100
  
  // Rule-based close signals
  if (Math.abs(priceChange) >= 10) {
    return {
      should_close: true,
      confidence: 90,
      reasoning: `Target profit/loss reached: ${priceChange.toFixed(2)}%`,
      expected_move: 0
    }
  }
  
  if (Math.abs(priceChange) >= 5) {
    return {
      should_close: true,
      confidence: 75,
      reasoning: `Significant price movement: ${priceChange.toFixed(2)}%`,
      expected_move: priceChange * 0.3
    }
  }
  
  return {
    should_close: false,
    confidence: 30,
    reasoning: 'Hold position - no strong close signals',
    expected_move: priceChange * 0.1
  }
}
```

### 5. Implementar WebSocket para Dados em Tempo Real
```typescript
// src/lib/auto-trader.ts
import { prisma } from '@/lib/db'
import { getMarketData } from './binance'
import { generateMLPrediction } from './ml-trainer'

export class AutoTrader {
  private userId: string
  private settings: any

  constructor(userId: string) {
    this.userId = userId
  }

  async initialize() {
    this.settings = await prisma.autoTradeSettings.findUnique({
      where: { userId: this.userId }
    })
    
    if (!this.settings) {
      throw new Error('Auto trade settings not found')
    }
  }

  async shouldExecuteTrade(): Promise<boolean> {
    // Verificar se auto trade est√° habilitado
    if (!this.settings.enabled) return false

    // Verificar limite di√°rio de trades
    const today = new Date()
    today.setHours(0, 0, 0, 0)
    
    const todayTrades = await prisma.trade.count({
      where: {
        userId: this.userId,
        isAutoTrade: true,
        createdAt: { gte: today }
      }
    })

    if (todayTrades >= this.settings.maxDailyTrades) {
      console.log('Limite di√°rio de trades atingido')
      return false
    }

    // Verificar intervalo m√≠nimo entre trades
    if (this.settings.lastTradeAt) {
      const timeSinceLastTrade = Date.now() - this.settings.lastTradeAt.getTime()
      const minInterval = this.settings.tradeInterval * 1000
      
      if (timeSinceLastTrade < minInterval) {
        console.log('Intervalo m√≠nimo entre trades n√£o atingido')
        return false
      }
    }

    return true
  }

  async executeAutoTrade() {
    if (!await this.shouldExecuteTrade()) return

    try {
      // Buscar previs√µes ML para ativos habilitados
      const tradeOpportunities = []
      
      for (const assetSymbol of this.settings.enabledAssets) {
        const marketData = await getMarketData(assetSymbol)
        const mlPrediction = await generateMLPrediction({
          symbol: assetSymbol,
          prices: [marketData.price], // Dados simplificados para exemplo
          volumes: [marketData.volume_24h],
          timestamps: [new Date().toISOString()],
          technical_indicators: {
            rsi: [50], // Valores simulados
            macd: [0],
            sma_20: [marketData.price],
            sma_50: [marketData.price],
            bb_upper: [marketData.price * 1.02],
            bb_lower: [marketData.price * 0.98]
          }
        })

        // Verificar se a previs√£o atende aos crit√©rios
        if (mlPrediction.confidence >= this.settings.minConfidence &&
            mlPrediction.prediction !== 'hold') {
          
          tradeOpportunities.push({
            asset: marketData,
            prediction: mlPrediction
          })
        }
      }

      if (tradeOpportunities.length === 0) {
        console.log('Nenhuma oportunidade de trade encontrada')
        return
      }

      // Selecionar melhor oportunidade (maior confian√ßa)
      const bestOpportunity = tradeOpportunities.reduce((best, current) => 
        current.prediction.confidence > best.prediction.confidence ? current : best
      )

      // Calcular tamanho do trade
      const baseAmount = 1000 * this.settings.riskMultiplier // Valor base
      const tradeAmount = Math.min(baseAmount, 5000) // Limitar a $5000

      // Executar trade
      const trade = await this.executeTrade({
        symbol: bestOpportunity.asset.symbol,
        type: bestOpportunity.prediction.prediction,
        amount: tradeAmount,
        price: bestOpportunity.asset.price,
        mlConfidence: bestOpportunity.prediction.confidence
      })

      // Atualizar estat√≠sticas
      await this.updateStats(trade)

      console.log('Auto trade executado com sucesso:', trade)
      
    } catch (error) {
      console.error('Erro ao executar auto trade:', error)
    }
  }

  private async executeTrade(tradeData: any) {
    const trade = await prisma.trade.create({
      data: {
        userId: this.userId,
        assetSymbol: tradeData.symbol,
        type: tradeData.type.toUpperCase(),
        amount: tradeData.amount,
        price: tradeData.price,
        mlConfidence: tradeData.mlConfidence,
        isAutoTrade: true,
        status: 'EXECUTED',
        executedAt: new Date()
      }
    })

    // Atualizar portfolio
    await this.updatePortfolio(tradeData)

    return trade
  }

  private async updatePortfolio(tradeData: any) {
    const portfolio = await prisma.portfolio.findUnique({
      where: {
        userId_assetSymbol: {
          userId: this.userId,
          assetSymbol: tradeData.symbol
        }
      }
    })

    if (portfolio) {
      // Atualizar portfolio existente
      const newAmount = tradeData.type === 'BUY' ? 
        portfolio.amount + (tradeData.amount / tradeData.price) :
        portfolio.amount - (tradeData.amount / tradeData.price)

      await prisma.portfolio.update({
        where: { id: portfolio.id },
        data: {
          amount: newAmount,
          value: newAmount * tradeData.price,
          updatedAt: new Date()
        }
      })
    } else {
      // Criar novo registro de portfolio
      const amount = tradeData.amount / tradeData.price
      await prisma.portfolio.create({
        data: {
          userId: this.userId,
          assetSymbol: tradeData.symbol,
          amount: amount,
          avgPrice: tradeData.price,
          value: amount * tradeData.price
        }
      })
    }
  }

  private async updateStats(trade: any) {
    await prisma.autoTradeSettings.update({
      where: { userId: this.userId },
      data: {
        totalTrades: { increment: 1 },
        lastTradeAt: new Date()
      }
    })
  }

  async getStats() {
    const stats = await prisma.autoTradeSettings.findUnique({
      where: { userId: this.userId }
    })

    const todayTrades = await prisma.trade.count({
      where: {
        userId: this.userId,
        isAutoTrade: true,
        createdAt: { gte: new Date(new Date().setHours(0, 0, 0, 0)) }
      }
    })

    return {
      ...stats,
      todayTrades,
      remainingTrades: stats.maxDailyTrades - todayTrades
    }
  }
}
```

## üéØ Benef√≠cios do Sistema

### üìà Performance Aprimorada
- **Decis√µes Baseadas em IA**: Previs√µes mais precisas com an√°lise LSTM
- **Gest√£o de Risco Ativa**: TP/SL autom√°ticos protegem contra perdas excessivas
- **Otimiza√ß√£o de Sa√≠da**: Fechamento inteligente maximiza lucros e minimiza perdas
- **Monitoramento 24/7**: Sistema operando continuamente sem interven√ß√£o manual

### üõ°Ô∏è Seguran√ßa e Controle
- **Limites de Risco**: Configura√ß√µes personaliz√°veis para controle total
- **Transpar√™ncia Completa**: Visualiza√ß√£o detalhada de todas as opera√ß√µes
- **Controle Manual**: Possibilidade de interven√ß√£o quando necess√°rio
- **Auditoria Completa**: Registro de todas as decis√µes e resultados

### üöÄ Escalabilidade
- **Arquitetura Modular**: F√°cil adi√ß√£o de novas funcionalidades
- **APIs Integradas**: Conex√£o com m√∫ltiplas fontes de dados
- **Suporte a M√∫ltiplos Ativos**: Expans√£o para novas criptomoedas
- **Aprendizado Cont√≠nuo**: Sistema melhora com o tempo

## üèÅ Como Come√ßar

### Pr√©-requisitos
- Node.js 18+ 
- npm ou yarn
- Conta em exchange de criptomoedas (para dados reais)

### Instala√ß√£o R√°pida
```bash
# Clonar o reposit√≥rio
git clone https://github.com/seu-usuario/ml-trading-bot.git
cd ml-trading-bot

# Instalar depend√™ncias
npm install

# Configurar vari√°veis de ambiente
cp .env.example .env
# Editar .env com suas chaves de API

# Iniciar desenvolvimento
npm run dev

# Acessar a aplica√ß√£o
http://localhost:3000
```

### Configura√ß√£o Inicial
1. **Configurar APIs de Mercado** (opcional para demo)
   - Adicionar chaves da Binance ou CoinGecko no `.env`
   - Testar conex√£o com as APIs

2. **Configurar Database** (opcional para demo)
   - Configurar PostgreSQL ou usar SQLite em mem√≥ria
   - Rodar migra√ß√µes do Prisma

3. **Personalizar Configura√ß√µes**
   - Ajustar par√¢metros de auto trade
   - Configurar n√≠veis de TP/SL
   - Selecionar ativos para monitorar

4. **Iniciar Trading**
   - Ativar o bot principal
   - Habilitar auto trade
   - Monitorar trades abertos na nova aba

## üìä M√©tricas de Sucesso

### Indicadores Chave
- **Taxa de Acerto**: Porcentagem de trades lucrativos
- **Profit Factor**: Raz√£o entre lucros e perdas
- **Drawdown M√°ximo**: Maior perda consecutiva
- **Sharpe Ratio**: Retorno ajustado ao risco

### Monitoramento Cont√≠nuo
- **Performance em Tempo Real**: Acompanhamento de P&L
- **An√°lise de Trades**: Identifica√ß√£o de padr√µes de sucesso
- **Otimiza√ß√£o de Par√¢metros**: Ajuste fino das configura√ß√µes
- **Relat√≥rios Detalhados**: Estat√≠sticas completas de performance

## ü§ù Contribui√ß√µes

Contribui√ß√µes s√£o bem-vindas! Por favor:

1. Fa√ßa um fork do projeto
2. Crie uma branch para sua feature (`git checkout -b feature/nova-funcionalidade`)
3. Commit suas mudan√ßas (`git commit -am 'Adiciona nova funcionalidade'`)
4. Push para a branch (`git push origin feature/nova-funcionalidade`)
5. Abra um Pull Request

## üìÑ Licen√ßa

Este projeto est√° sob a licen√ßa MIT - veja o arquivo [LICENSE](LICENSE) para detalhes.

## üôè Agradecimentos

- **ZAI SDK**: Por fornecer a infraestrutura de IA
- **shadcn/ui**: Pelos componentes UI de alta qualidade
- **Next.js**: Pelo framework web incr√≠vel
- **Comunidade Crypto**: Pela inspira√ß√£o e feedback

---

**‚ö†Ô∏è Aviso Importante**: Este √© um projeto educacional e de demonstra√ß√£o. Trading envolve riscos significativos e pode resultar em perdas financeiras. Sempre fa√ßa sua pr√≥pria pesquisa e considere consultar um advisor financeiro profissional antes de investir.
      try {
        for (const symbol of symbols) {
          const marketData = await getMarketData(symbol)
          socket.emit('market_update', marketData)
        }
      } catch (error) {
        socket.emit('error', { message: 'Erro ao buscar dados de mercado' })
      }
    })
    
    // Controlar auto trade
    socket.on('toggle_auto_trade', async (enabled) => {
      try {
        const autoTrader = autoTraders.get(socket.id)
        if (autoTrader) {
          await prisma.autoTradeSettings.update({
            where: { userId: autoTrader.userId },
            data: { enabled }
          })
          socket.emit('auto_trade_toggled', { enabled })
        }
      } catch (error) {
        socket.emit('auto_trade_error', { message: 'Erro ao alternar auto trade' })
      }
    })
    
    // Executar trade manual
    socket.on('execute_trade', async (tradeData) => {
      try {
        // Implementar l√≥gica de trade real aqui
        const result = await executeRealTrade(tradeData)
        socket.emit('trade_result', result)
      } catch (error) {
        socket.emit('trade_error', { message: 'Erro ao executar trade' })
      }
    })
    
    socket.on('disconnect', () => {
      console.log('Cliente desconectado:', socket.id)
      autoTraders.delete(socket.id)
    })
  })
}
```

## üéØ Benef√≠cios do Sistema

### üìà Performance Aprimorada
- **Decis√µes Baseadas em IA**: Previs√µes mais precisas com an√°lise LSTM
- **Gest√£o de Risco Ativa**: TP/SL autom√°ticos protegem contra perdas excessivas
- **Otimiza√ß√£o de Sa√≠da**: Fechamento inteligente maximiza lucros e minimiza perdas
- **Monitoramento 24/7**: Sistema operando continuamente sem interven√ß√£o manual

### üõ°Ô∏è Seguran√ßa e Controle
- **Limites de Risco**: Configura√ß√µes personaliz√°veis para controle total
- **Transpar√™ncia Completa**: Visualiza√ß√£o detalhada de todas as opera√ß√µes
- **Controle Manual**: Possibilidade de interven√ß√£o quando necess√°rio
- **Auditoria Completa**: Registro de todas as decis√µes e resultados

### üöÄ Escalabilidade
- **Arquitetura Modular**: F√°cil adi√ß√£o de novas funcionalidades
- **APIs Integradas**: Conex√£o com m√∫ltiplas fontes de dados
- **Suporte a M√∫ltiplos Ativos**: Expans√£o para novas criptomoedas
- **Aprendizado Cont√≠nuo**: Sistema melhora com o tempo

## üèÅ Como Come√ßar

### Pr√©-requisitos
- Node.js 18+ 
- npm ou yarn
- Conta em exchange de criptomoedas (para dados reais)

### Instala√ß√£o R√°pida
```bash
# Clonar o reposit√≥rio
git clone https://github.com/seu-usuario/ml-trading-bot.git
cd ml-trading-bot

# Instalar depend√™ncias
npm install

# Configurar vari√°veis de ambiente
cp .env.example .env
# Editar .env com suas chaves de API

# Iniciar desenvolvimento
npm run dev

# Acessar a aplica√ß√£o
http://localhost:3000
```

### Configura√ß√£o Inicial
1. **Configurar APIs de Mercado** (opcional para demo)
   - Adicionar chaves da Binance ou CoinGecko no `.env`
   - Testar conex√£o com as APIs

2. **Configurar Database** (opcional para demo)
   - Configurar PostgreSQL ou usar SQLite em mem√≥ria
   - Rodar migra√ß√µes do Prisma

3. **Personalizar Configura√ß√µes**
   - Ajustar par√¢metros de auto trade
   - Configurar n√≠veis de TP/SL
   - Selecionar ativos para monitorar

4. **Iniciar Trading**
   - Ativar o bot principal
   - Habilitar auto trade
   - Monitorar trades abertos na nova aba

## üìä M√©tricas de Sucesso

### Indicadores Chave
- **Taxa de Acerto**: Porcentagem de trades lucrativos
- **Profit Factor**: Raz√£o entre lucros e perdas
- **Drawdown M√°ximo**: Maior perda consecutiva
- **Sharpe Ratio**: Retorno ajustado ao risco

### Monitoramento Cont√≠nuo
- **Performance em Tempo Real**: Acompanhamento de P&L
- **An√°lise de Trades**: Identifica√ß√£o de padr√µes de sucesso
- **Otimiza√ß√£o de Par√¢metros**: Ajuste fino das configura√ß√µes
- **Relat√≥rios Detalhados**: Estat√≠sticas completas de performance

## ü§ù Contribui√ß√µes

Contribui√ß√µes s√£o bem-vindas! Por favor:

1. Fa√ßa um fork do projeto
2. Crie uma branch para sua feature (`git checkout -b feature/nova-funcionalidade`)
3. Commit suas mudan√ßas (`git commit -am 'Adiciona nova funcionalidade'`)
4. Push para a branch (`git push origin feature/nova-funcionalidade`)
5. Abra um Pull Request

## üìÑ Licen√ßa

Este projeto est√° sob a licen√ßa MIT - veja o arquivo [LICENSE](LICENSE) para detalhes.

## üôè Agradecimentos

- **ZAI SDK**: Por fornecer a infraestrutura de IA
- **shadcn/ui**: Pelos componentes UI de alta qualidade
- **Next.js**: Pelo framework web incr√≠vel
- **Comunidade Crypto**: Pela inspira√ß√£o e feedback

---

**‚ö†Ô∏è Aviso Importante**: Este √© um projeto educacional e de demonstra√ß√£o. Trading envolve riscos significativos e pode resultar em perdas financeiras. Sempre fa√ßa sua pr√≥pria pesquisa e considere consultar um advisor financeiro profissional antes de investir.
    Dados recentes: ${JSON.stringify(historicalData.slice(-10))}
    Indicadores t√©cnicos: ${JSON.stringify(technicalIndicators.slice(-5))}
    
    Com base nesses dados, forne√ßa:
    1. An√°lise de tend√™ncia
    2. N√≠veis de suporte e resist√™ncia
    3. Sinais de compra/venda
    4. Confian√ßa da previs√£o
    5. Pre√ßo alvo esperado
    
    Responda em formato JSON:
    {
      "trend": "bullish|bearish|neutral",
      "support": 45000,
      "resistance": 47000,
      "signal": "buy|sell|hold",
      "confidence": 85,
      "target_price": 46500
    }
    `
    
    const completion = await zai.chat.completions.create({
      messages: [
        {
          role: 'system',
          content: 'Voc√™ √© um analista de trading profissional especializado em an√°lise t√©cnica e machine learning.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.3
    })
    
    return JSON.parse(completion.choices[0]?.message?.content || '{}')
    
  } catch (error) {
    console.error('Erro no treinamento ML:', error)
    throw error
  }
}

function calculateTechnicalIndicators(data: any[]) {
  // Implementar c√°lculo de indicadores t√©cnicos reais
  return data.map((candle, index) => ({
    rsi: calculateRSI(data, index),
    macd: calculateMACD(data, index),
    sma20: calculateSMA(data, index, 20),
    sma50: calculateSMA(data, index, 50),
    bb_upper: calculateBollingerUpper(data, index),
    bb_lower: calculateBollingerLower(data, index),
  }))
}
```

### 7. Configurar Vari√°veis de Ambiente

#### ‚öôÔ∏è Arquivo .env
```env
# Database
DATABASE_URL="postgresql://username:password@localhost:5432/trading_bot"

# APIs
BINANCE_API_KEY="sua_binance_api_key"
BINANCE_API_SECRET="sua_binance_api_secret"
COINGECKO_API_KEY="sua_coingecko_api_key"

# NextAuth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="sua_chave_secreta"

# ZAI SDK
ZAI_API_KEY="sua_zai_api_key"

# WebSocket
SOCKET_PORT=3001

# Auto Trade
AUTO_TRADE_ENABLED=true
AUTO_TRADE_MAX_DAILY_TRADES=10
AUTO_TRADE_MIN_CONFIDENCE=75
AUTO_TRADE_INTERVAL=30
```

### 8. Executar com Dados Reais

#### üöÄ Script de Inicializa√ß√£o
```bash
#!/bin/bash

# 1. Instalar depend√™ncias
npm install

# 2. Configurar database
npx prisma migrate dev
npx prisma generate

# 3. Buildar aplica√ß√£o
npm run build

# 4. Iniciar servidor
npm run start
```

```typescript
// src/scripts/real-data-init.ts
import { prisma } from '../src/lib/db'
import { getMarketOverview } from '../src/lib/coingecko'
import { setupSocketHandlers, startMarketUpdates, startAutoTradeScheduler } from '../src/lib/socket'

async function initializeRealData() {
  try {
    console.log('Inicializando bot com dados reais...')
    
    // Buscar dados de mercado reais
    const marketData = await getMarketOverview()
    console.log(`Dados de ${marketData.length} ativos carregados`)
    
    // Salvar no database
    for (const asset of marketData) {
      await prisma.asset.upsert({
        where: { symbol: asset.symbol },
        update: {
          price: asset.price,
          change24h: asset.change_24h,
          volume24h: asset.volume_24h,
          marketCap: asset.market_cap,
          updatedAt: new Date()
        },
        create: {
          symbol: asset.symbol,
          name: asset.name,
          price: asset.price,
          change24h: asset.change_24h,
          volume24h: asset.volume_24h,
          marketCap: asset.market_cap
        }
      })
    }
    
    console.log('Dados de mercado salvos no database')
    
    // Inicializar configura√ß√µes de auto trade para usu√°rios existentes
    const users = await prisma.user.findMany()
    for (const user of users) {
      await prisma.autoTradeSettings.upsert({
        where: { userId: user.id },
        update: {},
        create: {
          userId: user.id,
          enabled: false,
          enabledAssets: ['BTC', 'ETH', 'SOL'],
          minConfidence: 75,
          maxDailyTrades: 10,
          tradeInterval: 30,
          riskMultiplier: 1.0
        }
      })
    }
    
    console.log('Configura√ß√µes de auto trade inicializadas')
    
    // Iniciar atualiza√ß√µes em tempo real
    const io = require('socket.io')(process.env.SOCKET_PORT || 3001)
    setupSocketHandlers(io)
    startMarketUpdates(io)
    startAutoTradeScheduler(io)
    
    console.log('Bot de trading com dados reais inicializado com sucesso!')
    console.log('ü§ñ Auto Trade scheduler iniciado')
    console.log('üì° Atualiza√ß√µes de mercado em tempo real ativadas')
    
  } catch (error) {
    console.error('Erro na inicializa√ß√£o:', error)
    process.exit(1)
  }
}

initializeRealData()
```

## ü§ñ **Funcionalidades de Auto Trade**

### ‚ú® **Caracter√≠sticas Principais:**

#### üéØ **Trading Automatizado Inteligente**
- **Execu√ß√£o Aut√¥noma**: O bot executa trades automaticamente baseado em previs√µes ML
- **Sele√ß√£o de Ativos**: Escolha quais ativos ser√£o monitorados para auto trade
- **Confian√ßa M√≠nima**: Define o n√≠vel m√≠nimo de confian√ßa para executar trades
- **Gest√£o de Risco**: Controle total sobre o tamanho e frequ√™ncia dos trades

#### ‚öôÔ∏è **Configura√ß√µes Avan√ßadas**
- **Ativos Habilitados**: Selecione quais criptomoedas o auto trade deve monitorar
- **Confian√ßa M√≠nima**: Ajuste de 50% a 95% para filtrar trades de alta qualidade
- **Limite Di√°rio**: Controle o n√∫mero m√°ximo de trades por dia (1-50)
- **Intervalo de Trades**: Defina o tempo m√≠nimo entre trades (10-300 segundos)
- **Multiplicador de Risco**: Ajuste o tamanho do trade baseado no seu apetite ao risco (0.1x-3.0x)

#### üìä **Monitoramento em Tempo Real**
- **Status do Auto Trade**: Indicadores visuais de quando o auto trade est√° ativo
- **Estat√≠sticas Detalhadas**: Acompanhe trades executados, sucesso e lucros
- **Regras Ativas**: Visualize todas as regras configuradas em tempo real
- **Alertas e Notifica√ß√µes**: Receba notifica√ß√µes quando trades s√£o executados

#### üõ°Ô∏è **Seguran√ßa e Controle**
- **Bot Principal Requerido**: Auto trade s√≥ funciona com o bot principal ativo
- **Limites de Prote√ß√£o**: M√∫ltiplas camadas de seguran√ßa para evitar perdas
- **Parada de Emerg√™ncia**: Desative o auto trade instantaneamente a qualquer momento
- **Hist√≥rico Completo**: Todos os trades autom√°ticos s√£o registrados para an√°lise

#### üß† **Integra√ß√£o com ML**
- **Previs√µes em Tempo Real**: Utiliza as previs√µes ML mais recentes para decis√µes
- **An√°lise T√©cnica**: Considera m√∫ltiplos indicadores t√©cnicos
- **Adapta√ß√£o Din√¢mica**: Ajusta estrat√©gias baseado nas condi√ß√µes de mercado
- **Aprendizado Cont√≠nuo**: Melhora com o tempo baseado nos resultados

## üìã Pr√©-requisitos

- Node.js 18+
- PostgreSQL
- Contas nas APIs (Binance, CoinGecko)
- Chaves de API necess√°rias

## üîß Instala√ß√£o

1. **Clonar o reposit√≥rio**
```bash
git clone <repositorio>
cd ml-trading-bot
```

2. **Instalar depend√™ncias**
```bash
npm install
```

3. **Configurar vari√°veis de ambiente**
```bash
cp .env.example .env
# Editar .env com suas credenciais
```

4. **Configurar database**
```bash
npx prisma migrate dev
npx prisma generate
```

5. **Executar aplica√ß√£o**
```bash
npm run dev
```

## üèóÔ∏è Arquitetura do Projeto

```
src/
‚îú‚îÄ‚îÄ app/                    # Next.js App Router
‚îÇ   ‚îú‚îÄ‚îÄ api/               # API Routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ trading/       # Trading APIs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ predict/   # ML Predictions
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ execute/   # Trade Execution
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ market/    # Market Data
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ autotrade/ # Auto Trade APIs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth/          # Authentication
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx           # Main Trading Interface
‚îÇ   ‚îî‚îÄ‚îÄ layout.tsx         # App Layout
‚îú‚îÄ‚îÄ components/            # React Components
‚îÇ   ‚îî‚îÄ‚îÄ ui/               # shadcn/ui Components
‚îú‚îÄ‚îÄ lib/                  # Utility Libraries
‚îÇ   ‚îú‚îÄ‚îÄ db.ts            # Database Connection
‚îÇ   ‚îú‚îÄ‚îÄ auth.ts          # Authentication
‚îÇ   ‚îú‚îÄ‚îÄ binance.ts       # Binance API
‚îÇ   ‚îú‚îÄ‚îÄ coingecko.ts     # CoinGecko API
‚îÇ   ‚îú‚îÄ‚îÄ socket.ts        # WebSocket Handlers
‚îÇ   ‚îú‚îÄ‚îÄ ml-trainer.ts    # ML Training
‚îÇ   ‚îî‚îÄ‚îÄ auto-trader.ts   # Auto Trade Logic
‚îú‚îÄ‚îÄ hooks/               # Custom React Hooks
‚îî‚îÄ‚îÄ scripts/             # Utility Scripts
```

## üéØ **Como Usar o Auto Trade**

### 1. **Configurar o Bot Principal**
- Primeiro, inicie o bot principal clicando em "Iniciar Bot"
- Aguarde a conex√£o com as APIs e carregamento dos dados

### 2. **Configurar Par√¢metros de Auto Trade**
- V√° para a aba "Auto Trade"
- Selecione os ativos que deseja monitorar
- Ajuste a confian√ßa m√≠nima (recomendado: 75%+)
- Defina o limite di√°rio de trades
- Configure o intervalo entre trades
- Ajuste o multiplicador de risco conforme seu perfil

### 3. **Ativar o Auto Trade**
- Clique no bot√£o "Auto Trade OFF" para ativ√°-lo
- O bot√£o mudar√° para "Auto Trade ON" (laranja)
- Monitor o status e estat√≠sticas em tempo real

### 4. **Monitorar e Ajustar**
- Acompanhe os trades executados no hist√≥rico
- Verifique as estat√≠sticas de performance
- Ajuste as configura√ß√µes conforme necess√°rio
- Desative o auto trade a qualquer momento se necess√°rio

## ‚ö†Ô∏è **Avisos Importantes**

### üö® **Riscos de Trading**
- **Alto Risco**: Trading de criptomoedas envolve riscos significativos
- **Perda Potencial**: Voc√™ pode perder todo o capital investido
- **Volatilidade**: Mercados de cripto s√£o extremamente vol√°teis
- **Use com Cautela**: Comece com valores pequenos para testar

### üîí **Seguran√ßa**
- **Mantenha Chaves Seguras**: Nunca compartilhe suas chaves de API
- **Use Contas de Teste**: Teste primeiro em ambientes de demonstra√ß√£o
- **Monitore Constantemente**: Acompanhe sempre as atividades do bot
- **Tenha Limites**: Use sempre stop loss e limites de tamanho de trade

### üìà **Performance**
- **Resultados Passados**: N√£o garantem resultados futuros
- **Condi√ß√µes de Mercado**: O desempenho varia conforme o mercado
- **Manuten√ß√£o**: Requer monitoramento e ajustes regulares
- **Atualiza√ß√µes**: Mantenha o sistema atualizado para melhor performance

## üéØ Features Futuras

- [ ] Integra√ß√£o com mais exchanges (Kraken, Coinbase)
- [ ] Modelos de ML mais avan√ßados (Transformer, GANs)
- [ ] Backtesting completo com dados hist√≥ricos
- [ ] Sistema de notifica√ß√µes push
- [ ] Mobile app nativo
- [ ] API para terceiros
- [ ] Sistema de affiliate e indica√ß√µes
- [ ] Estrat√©gias de trading personaliz√°veis
- [ ] An√°lise de sentimento de mercado
- [ ] Otimiza√ß√£o de portf√≥lio autom√°tica

## üìÑ Licen√ßa

Este projeto est√° sob licen√ßa MIT. Veja o arquivo LICENSE para mais detalhes.

## ü§ù Contribui√ß√µes

Contribui√ß√µes s√£o bem-vindas! Por favor, leia o CONTRIBUTING.md para detalhes sobre nosso c√≥digo de conduta e o processo de submiss√£o de pull requests.

## üìû Suporte

Para suporte, envie um email para suporte@tradingbot.com ou crie uma issue no GitHub.

---

**‚ö†Ô∏è Aviso Importante**: Este bot de trading √© para fins educacionais e demonstrativos. Trading de criptomoedas envolve riscos significativos e pode resultar em perdas. Sempre fa√ßa sua pr√≥pria pesquisa e consulte um consultor financeiro antes de investir. O auto trade deve ser usado com extrema cautela e apenas por traders experientes.